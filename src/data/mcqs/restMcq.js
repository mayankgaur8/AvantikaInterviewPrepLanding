// src/data/mcqs/restMcq.js
// ✅ Named export (matches: import { REST_MCQ } from "./mcqs/restMcq";)

export const REST_MCQ = [
  {
    tag: "REST • Easy",
    q: "What does REST stand for?",
    options: [
      "Remote Execution and Secure Transport",
      "Representational State Transfer",
      "Reliable State Transaction",
      "Resource Encoded Standard Transfer",
    ],
    answer: 1,
    explain: "REST stands for Representational State Transfer (architectural style for web APIs).",
  },
  {
    tag: "REST • Easy",
    q: "Which is a key REST principle?",
    options: [
      "APIs must use SOAP",
      "Stateless client-server communication",
      "All requests must be encrypted",
      "Server must keep user session state",
    ],
    answer: 1,
    explain: "REST is stateless: each request carries everything the server needs to process it.",
  },
  {
    tag: "REST • Easy",
    q: "Which HTTP method is typically used to fetch a resource?",
    options: ["POST", "GET", "PUT", "PATCH"],
    answer: 1,
    explain: "GET retrieves a representation of a resource.",
  },
  {
    tag: "REST • Easy",
    q: "Which HTTP method is typically used to create a new resource?",
    options: ["GET", "POST", "PUT", "DELETE"],
    answer: 1,
    explain: "POST is commonly used to create resources (server assigns the new resource URI).",
  },
  {
    tag: "REST • Easy",
    q: "Which HTTP method is typically used to delete a resource?",
    options: ["DELETE", "PUT", "POST", "PATCH"],
    answer: 0,
    explain: "DELETE removes a resource identified by the URI.",
  },
  {
    tag: "REST • Easy",
    q: "Which HTTP method is typically used to update a resource completely?",
    options: ["GET", "POST", "PUT", "PATCH"],
    answer: 2,
    explain: "PUT usually replaces the full representation; PATCH is partial update.",
  },
  {
    tag: "REST • Easy",
    q: "Which HTTP method is typically used to update a resource partially?",
    options: ["GET", "PUT", "PATCH", "DELETE"],
    answer: 2,
    explain: "PATCH is designed for partial updates.",
  },
  {
    tag: "REST • Easy",
    q: "What does an HTTP 200 status code mean?",
    options: ["Created", "OK (success)", "No Content", "Bad Request"],
    answer: 1,
    explain: "200 OK indicates the request succeeded (response body may be present).",
  },
  {
    tag: "REST • Easy",
    q: "What does an HTTP 201 status code mean?",
    options: ["OK", "Accepted", "Created", "No Content"],
    answer: 2,
    explain: "201 Created indicates a new resource was created (often with Location header).",
  },
  {
    tag: "REST • Easy",
    q: "What does an HTTP 204 status code mean?",
    options: ["No Content", "Not Found", "Created", "Unauthorized"],
    answer: 0,
    explain: "204 No Content means success but no response body (common for DELETE).",
  },

  // ---------------------- Intermediate (11-35) ----------------------
  {
    tag: "REST • Medium",
    q: "Which HTTP status code is best for validation errors in request payload?",
    options: ["400", "401", "404", "500"],
    answer: 0,
    explain: "400 Bad Request is commonly used for invalid input/validation failures.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code indicates authentication is required or failed?",
    options: ["401", "403", "404", "409"],
    answer: 0,
    explain: "401 Unauthorized indicates missing/invalid authentication credentials.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code indicates the user is authenticated but not allowed?",
    options: ["401", "403", "405", "429"],
    answer: 1,
    explain: "403 Forbidden means the server understood the request but refuses to authorize it.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code indicates the requested resource doesn't exist?",
    options: ["400", "404", "409", "500"],
    answer: 1,
    explain: "404 Not Found indicates the resource is not available.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code indicates a conflict, e.g., duplicate unique key on create?",
    options: ["409", "404", "422", "500"],
    answer: 0,
    explain: "409 Conflict is appropriate for state conflicts like duplicates or version mismatch.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code indicates too many requests (rate limiting)?",
    options: ["408", "409", "429", "503"],
    answer: 2,
    explain: "429 Too Many Requests indicates the client hit a rate limit.",
  },
  {
    tag: "REST • Medium",
    q: "What header is commonly used to send authentication token?",
    options: ["Accept", "Authorization", "Host", "ETag"],
    answer: 1,
    explain: "`Authorization: Bearer <token>` is the standard pattern for token auth.",
  },
  {
    tag: "REST • Medium",
    q: "Which header is used by clients to specify expected response format?",
    options: ["Content-Type", "Accept", "Cache-Control", "Origin"],
    answer: 1,
    explain: "Accept tells the server what media types the client can process.",
  },
  {
    tag: "REST • Medium",
    q: "Which header describes the request body media type?",
    options: ["Accept", "Content-Type", "ETag", "Location"],
    answer: 1,
    explain: "Content-Type indicates the format of the request body (e.g., application/json).",
  },
  {
    tag: "REST • Medium",
    q: "Which is the correct way to version REST APIs?",
    options: [
      "Only by changing DB schema version",
      "Use URL (/v1/...), header (Accept), or query param (less preferred)",
      "Never version APIs",
      "Only by changing HTTP methods",
    ],
    answer: 1,
    explain:
      "Common strategies: URI versioning (/v1), header-based (media type), sometimes query param.",
  },
  {
    tag: "REST • Medium",
    q: "Which is a recommended REST resource naming practice?",
    options: [
      "Use verbs in paths (e.g., /getUsers)",
      "Use plural nouns (e.g., /users) and HTTP methods for actions",
      "Use file extensions (e.g., /users.json)",
      "Use uppercase paths (e.g., /USERS)",
    ],
    answer: 1,
    explain: "Prefer nouns for resources; rely on HTTP verbs for actions.",
  },
  {
    tag: "REST • Medium",
    q: "Which is a best practice for pagination?",
    options: [
      "Return all data always",
      "Use limit/offset or cursor-based pagination with metadata",
      "Use only POST for pagination",
      "Use only cookies for pagination",
    ],
    answer: 1,
    explain:
      "Use page size and offsets or cursor tokens; include total/count/next cursor where possible.",
  },
  {
    tag: "REST • Medium",
    q: "Which approach avoids missing/duplicated results in changing datasets?",
    options: ["Offset pagination", "Cursor-based pagination", "No pagination", "Random paging"],
    answer: 1,
    explain: "Cursor-based pagination is more stable when data changes frequently.",
  },
  {
    tag: "REST • Medium",
    q: "What is idempotency in HTTP methods?",
    options: [
      "Request always returns JSON",
      "Repeating the same request produces the same effect on server state",
      "Request always uses TLS",
      "Request must have a body",
    ],
    answer: 1,
    explain: "Idempotent means multiple identical requests result in the same state as one.",
  },
  {
    tag: "REST • Medium",
    q: "Which methods are typically idempotent?",
    options: ["POST only", "GET, PUT, DELETE (and HEAD/OPTIONS)", "PATCH only", "POST and PATCH"],
    answer: 1,
    explain: "GET/PUT/DELETE are defined as idempotent; POST usually is not.",
  },
  {
    tag: "REST • Medium",
    q: "What is a safe HTTP method?",
    options: [
      "A method that always uses HTTPS",
      "A method that doesn't change server state (read-only)",
      "A method that always returns 200",
      "A method that requires auth",
    ],
    answer: 1,
    explain: "Safe methods (GET/HEAD) do not modify server state.",
  },
  {
    tag: "REST • Medium",
    q: "What is HATEOAS?",
    options: [
      "A caching algorithm",
      "Hypermedia links included in responses to guide clients",
      "A security protocol",
      "A DB indexing strategy",
    ],
    answer: 1,
    explain:
      "HATEOAS = Hypermedia As The Engine Of Application State, links in responses to navigate API.",
  },
  {
    tag: "REST • Medium",
    q: "What is the purpose of ETag header?",
    options: [
      "Authentication token",
      "Content encoding method",
      "Caching/conditional request identifier for a resource version",
      "CORS policy",
    ],
    answer: 2,
    explain: "ETag represents a version/fingerprint for caching and conditional requests.",
  },
  {
    tag: "REST • Medium",
    q: "Which headers support conditional GET to reduce bandwidth?",
    options: ["If-None-Match / If-Modified-Since", "Authorization / Cookie", "Origin / Referer", "X-Frame-Options"],
    answer: 0,
    explain: "If-None-Match (ETag) and If-Modified-Since enable conditional requests.",
  },
  {
    tag: "REST • Medium",
    q: "Which status code is returned when ETag matches and resource not modified?",
    options: ["200", "201", "304", "412"],
    answer: 2,
    explain: "304 Not Modified indicates cached version can be used.",
  },
  {
    tag: "REST • Medium",
    q: "Which header tells the client where a newly created resource lives?",
    options: ["Location", "ETag", "Accept", "Server"],
    answer: 0,
    explain: "Location is commonly returned with 201 Created to point to the new resource URI.",
  },
  {
    tag: "REST • Medium",
    q: "How do you represent filtering in REST APIs?",
    options: [
      "Use GET body always",
      "Use query params (e.g., /users?status=active)",
      "Use only headers",
      "Use only cookies",
    ],
    answer: 1,
    explain: "Filtering is typically done using query parameters.",
  },
  {
    tag: "REST • Medium",
    q: "What is the main difference between PUT and PATCH?",
    options: [
      "PUT is for partial update, PATCH is full update",
      "PUT usually replaces full resource, PATCH applies partial changes",
      "PUT works only with JSON, PATCH only with XML",
      "No difference",
    ],
    answer: 1,
    explain: "PUT generally replaces a resource; PATCH modifies parts of it.",
  },
  {
    tag: "REST • Medium",
    q: "What is a typical content type for JSON responses?",
    options: ["text/plain", "application/json", "application/xml", "multipart/form-data"],
    answer: 1,
    explain: "application/json is the standard media type for JSON payloads.",
  },

  // ---------------------- Advanced (36-50) ----------------------
  {
    tag: "REST • Hard",
    q: "What is optimistic locking in REST APIs commonly implemented with?",
    options: ["ETag + If-Match", "Cache-Control", "CORS", "Cookie-based sessions"],
    answer: 0,
    explain:
      "Use ETag to represent version and require If-Match on updates; server rejects stale updates.",
  },
  {
    tag: "REST • Hard",
    q: "Which status code fits when If-Match precondition fails (stale ETag)?",
    options: ["409", "412", "422", "500"],
    answer: 1,
    explain: "412 Precondition Failed is used when conditional request preconditions fail.",
  },
  {
    tag: "REST • Hard",
    q: "What is the best practice for long-running async operations in REST?",
    options: [
      "Block request until complete always",
      "Return 202 + Location to status endpoint (polling)",
      "Always use WebSockets",
      "Return 500 and retry",
    ],
    answer: 1,
    explain:
      "Return 202 Accepted and a URL (Location) to check status/result; optionally use callbacks/webhooks.",
  },
  {
    tag: "REST • Hard",
    q: "Which status code indicates the server accepted the request for processing later?",
    options: ["200", "202", "204", "301"],
    answer: 1,
    explain: "202 Accepted means the request is accepted but processing is not completed.",
  },
  {
    tag: "REST • Hard",
    q: "What is the main advantage of cursor pagination over offset pagination?",
    options: [
      "Easier to implement in UI",
      "More stable and efficient for large/fast-changing datasets",
      "Requires no indexes",
      "Always returns total count",
    ],
    answer: 1,
    explain:
      "Cursor avoids deep offset scans and reduces inconsistencies when records are inserted/deleted.",
  },
  {
    tag: "REST • Hard",
    q: "Which HTTP method is commonly used for preflight requests in CORS?",
    options: ["HEAD", "OPTIONS", "TRACE", "CONNECT"],
    answer: 1,
    explain: "Browsers send OPTIONS preflight to check permitted methods/headers for cross-origin calls.",
  },
  {
    tag: "REST • Hard",
    q: "Which header controls how long a response can be cached?",
    options: ["Cache-Control", "Authorization", "Location", "Set-Cookie"],
    answer: 0,
    explain: "Cache-Control directives (max-age, no-cache, no-store) govern caching behavior.",
  },
  {
    tag: "REST • Hard",
    q: "Which is a good strategy to ensure POST is idempotent (e.g., payments)?",
    options: [
      "Use random delays",
      "Use an Idempotency-Key header stored server-side",
      "Use GET instead of POST",
      "Disable retries",
    ],
    answer: 1,
    explain:
      "Clients send Idempotency-Key; server deduplicates repeated requests with same key.",
  },
  {
    tag: "REST • Hard",
    q: "Which response is best when client sends unsupported media type in Content-Type?",
    options: ["400", "415", "406", "500"],
    answer: 1,
    explain: "415 Unsupported Media Type is used when request payload format is not supported.",
  },
  {
    tag: "REST • Hard",
    q: "Which response is best when server cannot produce a response matching Accept header?",
    options: ["404", "406", "415", "503"],
    answer: 1,
    explain: "406 Not Acceptable indicates server cannot generate a representation acceptable to client.",
  },
  {
    tag: "REST • Hard",
    q: "What is a common approach for structured API error responses?",
    options: [
      "Return plain text always",
      "Use a consistent JSON error shape (code/message/details) or RFC7807 Problem Details",
      "Return HTML pages",
      "Return stack traces to client",
    ],
    answer: 1,
    explain:
      "Consistent error schema improves client handling; many APIs adopt Problem Details (RFC7807).",
  },
  {
    tag: "REST • Hard",
    q: "How do you prevent over-fetching/under-fetching in REST without GraphQL?",
    options: [
      "Always return full object graphs",
      "Use sparse fieldsets (fields=) and embedding options (include=)",
      "Use only POST",
      "Disable caching",
    ],
    answer: 1,
    explain:
      "Field selection and controlled embedding let clients request only what they need.",
  },
  {
    tag: "REST • Hard",
    q: "Which approach best supports partial responses (field selection) in REST?",
    options: [
      "fields=name,email query param",
      "Custom HTTP method",
      "Request body in GET",
      "Always return 204",
    ],
    answer: 0,
    explain: "Using query params like `fields=` is a common pattern to shape responses.",
  },
  {
    tag: "REST • Hard",
    q: "Which principle helps REST APIs scale by enabling intermediaries?",
    options: [
      "Session affinity",
      "Layered system + cacheability",
      "Tight coupling",
      "Server-side UI rendering",
    ],
    answer: 1,
    explain:
      "Layered system and cacheable responses allow proxies/CDNs and other intermediaries to help scale.",
  },
  {
    tag: "REST • Hard",
    q: "Which is a best practice for handling breaking changes in APIs?",
    options: [
      "Deploy without notice",
      "Introduce a new version and deprecate old with timeline",
      "Change response fields randomly",
      "Remove old endpoints immediately",
    ],
    answer: 1,
    explain: "Create a new version, keep backward compatibility as long as possible, and deprecate safely.",
  },
];
